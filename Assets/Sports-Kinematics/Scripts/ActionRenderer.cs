using System;
using System.Collections.Generic;
using UnityEngine;
using Kinect = Windows.Kinect;
using UnityEngine.UI;
using UnityEngine.EventSystems;
namespace SportsKinematics
{
    public class ActionRenderer : MonoBehaviour
    {
        public GameObject opp_placeholder;
        /// <summary>
        /// The fps of the fixed update
        /// </summary>
        private const int physFPS = 50;

        /// <summary>
        /// If the script is called in the editor or not
        /// </summary>
        public bool m_isEditor = false;
        public BallBehaviour dball;

        /// <summary>
        /// Action to be loaded
        /// </summary>
        private Action m_action;

        private float m_startTime;

        /// <summary>
        /// Script reference to draws striker object
        /// </summary>
        private StrikerRenderer m_strikerScript;

        /// <summary>
        /// Dictionary of JointType, JointType. Allows drawing of bones between joints.
        /// </summary>
        private Dictionary<Kinect.JointType, Kinect.JointType> m_boneDic;

        /// <summary>
        /// reference of player's body, dynamically generated by moCap system.
        /// </summary>
        private GameObject m_trackedBody = null;

        /// <summary>
        /// Frame currently being rendered
        /// </summary>
        private int m_renderFrame;

        /// <summary>
        /// Last frame to be rendered
        /// </summary>
        private int m_maxFrame;

        /// <summary>
        /// scale used by kinect to resize cubes as joints
        /// </summary>
        private float[] m_kinectScale = { 0.3f, 0.3f, 0.3f };

        /// <summary>
        /// Applicable amount to Lerp
        /// </summary>
        private float m_LerpMinimum;

        /// <summary>
        /// Capture facade  script for data capture and member variable accessing
        /// </summary>
        private CaptureFacade m_captureFacade;

        /// <summary>
        /// Test for scene reset
        /// </summary>
        private bool m_reset;

        /// <summary>
        /// check if finished rendering all data
        /// </summary>
        private bool m_reachedEnd;

        /// <summary>
        /// used to change speed of render playback
        /// </summary>
        private int m_speedCounter;

        /// <summary>
        /// last time a function was called. Used to determine delta times.
        /// </summary>
        private float m_lastTime;

        /// <summary>
        /// time that simulation has been running, as scaled by speed. Displayed during editing.
        /// </summary>
        private float m_timer;

        /// <summary>
        /// time that simulation has been running, used for temporal occlusion.
        /// </summary>
        private float m_occTimer;

        /// <summary>
        /// time to release ball. Dynamically calculated.
        /// </summary>
        private float m_ballReleaseTime;

        /// <summary>
        /// frame to hit a paddle.
        /// </summary>
        private float m_ballTargetFrame;

        /// <summary>
        /// configuration for the action being replayed. Allows for scene resetting to affect configuration.
        /// </summary>
        private Configuration m_conf;


        /// <summary>
        /// determine if hit has occured. on "no hit" temporal occlusion, sets to true on first frame. 
        /// </summary>
        public bool m_hitOccured;

        /// <summary>
        /// GameObject reference for capture facade
        /// </summary>
        public GameObject captureFacade;

        /// <summary>
        /// GameObject reference for record kinect data
        /// </summary>
        public GameObject recordKinectData;

        /// <summary>
        /// Script reference for record kinect data
        /// </summary>
        RecordKinectData m_rkd;

        /// <summary>
        /// Game Object reference to striker manager for opponent. allows rendering of striker.
        /// </summary>
        public GameObject m_strikerManager;

        /// <summary>
        /// Ball prefab
        /// </summary>
        public GameObject m_ball;

        /// <summary>
        /// table prefab
        /// </summary>
        public GameObject m_table;

        /// <summary>
        /// Maximum allowable speed
        /// </summary>
        public const float m_MAX_SPEED = 500f;

        /// <summary>
        /// determine if opponent is playing right handed
        /// </summary>
        public bool m_HandRight;

        /// <summary>
        /// determine whether or not to draw lines on the opponent
        /// </summary>
        public bool m_drawLines;

        /// <summary>
        /// Max time before occlusion
        /// </summary>
        public float m_maxTime;

        /// <summary>
        /// determine whether or not to play back simulation
        /// </summary>
        public bool m_play;

        /// <summary>
        /// release time for ball
        /// </summary>
        private float m_releaseTime;

        public Experiment m_exp;
        public Occlusion m_occ;

        /// <summary>
        /// Initiate the objects in scene
        /// </summary>
        void InitObjects()
        {
            m_captureFacade = captureFacade.GetComponent<CaptureFacade>();
            m_boneDic = m_captureFacade.BodyView.GetJointDic;
            m_strikerScript = m_strikerManager.GetComponent<StrikerRenderer>();
        }

        /// <summary>
        /// Initiate all non object data in scene
        /// </summary>
        void InitValues()
        {
            m_renderFrame = 0;
            m_maxFrame = 0;
            m_drawLines = true;

            m_occTimer = 0.0f;
            m_LerpMinimum = 1f;
            m_speedCounter = 0;
            m_maxTime = 0.001f;

            if (m_action == null)
                m_action = new Action();

            m_play = false;
            m_hitOccured = false;
            m_HandRight = true;
            m_reset = false;
        }

        /// <summary>
        /// GameObject start
        /// </summary>
        void Start()
        {
            if (recordKinectData && !m_rkd)
                m_rkd = recordKinectData.GetComponent<RecordKinectData>();

            InitObjects();
            if (!m_isEditor)
            {
                InitValues();

            }
        }

        /// <summary>
        /// accessor for render frame.
        /// </summary>
        public int RenderFrame
        {
            get { return m_renderFrame; }
            set { m_renderFrame = value; }
        }

        /// <summary>
        /// Maximum possible frame
        /// Author: Olesia Kochergina
        /// </summary>
        public int FrameMax
        {
            get { return m_maxFrame; }

            set { m_maxFrame = value; }
        }

        /// <summary>
        /// Occludes all joints drawn to screen. Used to apply temporal occlusion
        /// </summary>
        public void OccludeAllJoints(bool active)
        {
            for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt <= Kinect.JointType.ThumbRight; jt++)
            {
                m_exp.m_occBoolArr[(int)jt + Experiment.m_jointOffset] = active;

                if (jt == Kinect.JointType.ThumbRight)
                {
                    // m_ball.layer = LayerMask.NameToLayer("Occluded");
                }
            }
        }



        /// <summary>
        /// locally store a configuration, and apply it to the scene
        /// </summary>
        /// <param name="conf">configuration to be initialised</param>
        public void InitConfig(Configuration conf)
        {
            //m_occBoolArr = conf.OcclusionArray;


            if (!conf.TemporalOnHitIsActive)
            {
                m_maxTime = 0.0f;
                m_hitOccured = true;
            }

            if (conf.OcclusionTime != 0.0f)
                m_maxTime = conf.OcclusionTime;

            if (conf.CollisionFrame != 0.0f)
            {
                m_ballTargetFrame = conf.CollisionFrame;//*1000.0f;
                m_releaseTime = (float.Parse(m_ballTargetFrame.ToString()) / 50f) - 0.02f; //fixed update rate
            }

            m_strikerScript.m_StrikerSelection = conf.Sport;
            m_HandRight = conf.OpponentRightHanded;

            if (conf.Sport != 0)
            {
                //m_strikerScript.m_start = conf.StartingRotation;
                //m_strikerScript.m_final = conf.EndingRotation;
            }

            GameObject playerStriker = GameObject.Find("SportsKinematics/Retriever");

            if (playerStriker)
            {
                playerStriker.GetComponent<PlayerTracker>().LoadConf(conf);
            }

            m_conf = conf;
        }

        /// <summary>
        /// Update loop. runs on physics engine and is guaranteed to occur at 50 fps
        /// </summary>
        void FixedUpdate()
        {
            m_reachedEnd = false;

            if (m_play && m_exp.m_speed != 0.0f && !m_reachedEnd)
            {
                if (m_exp.FrameBall - 2 == m_renderFrame)
                {
                    //dball.UpdateDestination();
                    // Debug.Log("ball frame: " + m_exp.FrameBall);
                    dball.ApplyImpulse();
                }
                UpdateBody();

                if (m_renderFrame < m_maxFrame - 3)
                {
                    m_renderFrame += (int)m_exp.m_speed / physFPS;
                }
                OccludeObject(dball.gameObject, 1);
                OccludeObject(GameObject.Find("PaddleParent").transform.GetChild(0).gameObject, 0);

            }
            else
            {
                m_lastTime = Time.time;
            }

            if ((m_occTimer >= m_maxTime && m_maxTime > 0.0f) || (m_hitOccured && m_maxTime == 0.001f))
            {
                Debug.Log("Occlude");
                OccludeAllJoints(false);
            }
        }

        private void OccludeObject(GameObject go, int index)
        {
            if (go)
            {

                if ((m_exp.m_occFrameMin[index] >= m_renderFrame && m_exp.m_occFrameMax[index] >= m_renderFrame)
                            || (m_exp.m_occFrameMin[index] <= m_renderFrame && m_exp.m_occFrameMax[index] <= m_renderFrame))
                {
                    go.layer = LayerMask.NameToLayer("Default");
                }
                else
                {
                    go.layer = LayerMask.NameToLayer("Occluded");
                }
            }
        }

        /// <summary>
        /// Updates the skeleton even if the editing video is not playing.
        /// Useful for the range slider min lower value modifications.
        /// Author: Olesia Kochergina
        /// </summary>
        public void UpdateBody()
        {

            if (m_trackedBody)
            {
                try
                {
                    RefreshBody(m_trackedBody);
                    OccludeObject(m_ball, 1);
                    //if (m_ball)
                    //{
                    //    if ((m_exp.m_occFrameMin[1] >= m_renderFrame && m_exp.m_occFrameMax[1] >= m_renderFrame)
                    //         || (m_exp.m_occFrameMin[1] <= m_renderFrame && m_exp.m_occFrameMax[1] <= m_renderFrame))

                    //    {
                    //        m_ball.layer = LayerMask.NameToLayer("Default");
                    //    }
                    //    else
                    //    {
                    //        m_ball.layer = LayerMask.NameToLayer("Occluded");
                    //    }
                    //}

                }
                catch
                {
                    Debug.Log("Body not found!");
                }
            }
            else
            {

                Debug.Log("No Body");
            }
        }

        /// <summary>
        /// Initiate the render body for opponent actions
        /// </summary>
        /// <param name="action">action data to display</param>
        public void InitiateRenderBody(Action action)
        {
            m_exp = new Experiment();
            m_exp.Start();

            if (!m_captureFacade)
            {
                InitObjects();
                InitValues();
            }
            m_action = action;

            // m_maxFrame = m_action.Count;
            if (m_isEditor)
            {
                m_exp.FrameEnd = m_action.Count;
                for (int i = 0; i < m_exp.m_occFrameMax.Length; i++)
                {
                    m_exp.m_occFrameMax[i] = m_maxFrame;
                    m_exp.m_occFrameMin[i] = m_maxFrame;
                }
            }
            m_exp.ReadConfig(m_isEditor, m_action.Name);
            if (!m_isEditor && dball != null)
            {
                //Debug.Log("action name: " + m_action.Name);
                //Debug.Log("ball occlusion: " + m_exp.m_occFrameMin[11]);
                dball.m_destination = m_exp.m_ballDest;
                dball.m_ballSpeed = m_exp.m_ballSpeed;
            }

            if (m_trackedBody == null)
            {

                try
                {
                    m_trackedBody = RenderBody();
                    //if (m_ball)
                    //{
                    //    //Determine ball target
                    //    DetermineBallTarget(m_trackedBody);
                    //}
                }
                catch
                {
                }
            }

            m_reachedEnd = false;
        }



        /// <summary>
        /// Access Action position data for current and next frame
        /// </summary>
        /// <param name="actionPosition">current frame data as Dictionary of JointType to float[3]</param>
        /// <param name="nextActionPosition">next frame data as Dictionary of JointType to float[3]</param>
        public void GetActionPositionData(out Dictionary<Kinect.JointType, float[]> actionPosition, out Dictionary<Kinect.JointType, float[]> nextActionPosition)
        {
            actionPosition = m_action.CurrentActionPositionData[m_renderFrame];
            nextActionPosition = m_action.CurrentActionPositionData[m_renderFrame + 1];
        }

        /// <summary>
        /// Access Action orientation data for current and next frame
        /// </summary>
        /// <param name="actionOrientation">current frame data as Dictionary of JointType to float[3]</param>
        /// <param name="nextActionOrientation">next frame data as Dictionary of JointType to float[3]</param>
        public void GetActionOrientationData(out Dictionary<Kinect.JointType, float[]> actionOrientation, out Dictionary<Kinect.JointType, float[]> nextActionOrientation)
        {
            actionOrientation = m_action.CurrentActionOrientationData[m_renderFrame];
            nextActionOrientation = m_action.CurrentActionOrientationData[m_renderFrame + 1];
        }

        /// <summary>
        /// Render the opponent body
        /// </summary>
        /// <returns>returns the body that was drawn</returns>
        //FR1 - Virtual opponent modelling from captured data.
        private GameObject RenderBody()
        {
            GameObject body = new GameObject("Opponent");
            body.transform.position = new Vector3(-8f, 3.2f, 12);
            body.transform.rotation = new Quaternion(0f, 180f, 0f, 1f);
            body.transform.localScale = new Vector3(-1f, 1f, 1f);

            // Debug.Log("fsd2");
            RenderJoints(body);
            //Debug.Log("fsd3");

            RefreshBody(body);
            //Debug.Log("fsd4");
            RefreshBody(body);  //fixes a transform issue
            //Debug.Log("fsd4.5");
            if (m_occ != null)
                m_occ.Start(m_exp, body);
            else
                m_occ = new Occlusion();
            if (m_isEditor)
                m_occ.AddSkeletonOcclusionOptions(body);
            //fix for simulation
            m_trackedBody = body;
            Debug.Log("Completed Body Init");
            ResetRenderFrame();

            if (opp_placeholder)
                body.transform.parent = opp_placeholder.transform;
            return body;
        }

        public void SaveRecording()
        {
            m_exp.FrameStart = m_renderFrame;
            m_exp.FrameEnd = m_maxFrame;
            EditingManager.isEditedRecording = true;
        }




        /// <summary>
        /// Render joints to screen and draw striker
        /// </summary>
        /// <param name="body">body that has been rendered</param>
        public void RenderJoints(GameObject body)
        {
            Dictionary<Kinect.JointType, float[]> actionPositionData;
            Dictionary<Kinect.JointType, float[]> nextActionPositionData;
            GetActionPositionData(out actionPositionData, out nextActionPositionData);
            Dictionary<Kinect.JointType, float[]> actionOrientationData;
            Dictionary<Kinect.JointType, float[]> nextActionOrientationData;
            GetActionOrientationData(out actionOrientationData, out nextActionOrientationData);
            for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt <= Kinect.JointType.ThumbRight; jt++)
            {
                GameObject jointObj = GameObject.CreatePrimitive(PrimitiveType.Cube);

                jointObj.transform.localScale = FloatToVec(m_kinectScale);
                jointObj.name = jt.ToString();

                Kinect.JointType target;
                m_boneDic.TryGetValue(jt, out target);

                float[] jointStart;
                actionPositionData.TryGetValue(jt, out jointStart);

                float[] jointEnd = null;
                actionPositionData.TryGetValue(target, out jointEnd);

                jointObj.transform.parent = body.transform;
                jointObj.transform.localPosition = FloatToVec(jointStart);
                if (!m_exp.m_occBoolArr[(int)jt + Experiment.m_jointOffset])
                {
                    jointObj.GetComponent<MeshRenderer>().material = Occlusion.m_inactiveJoint;
                    // GameObject.Find("Opponent/" + jt.ToString()).layer = LayerMask.NameToLayer("Occluded");
                }
                else
                {

                    jointObj.GetComponent<MeshRenderer>().material = Occlusion.m_activeJoint;
                }
                //draw striker
                if (jt == Kinect.JointType.HandRight && m_HandRight)
                {
                    CreateStrikerOnHand(jointObj.transform, jt, m_exp.m_occBoolArr[(int)jt + Experiment.m_jointOffset]);
                }
                else if (jt == Kinect.JointType.HandLeft && !m_HandRight)
                {
                    CreateStrikerOnHand(jointObj.transform, jt, m_exp.m_occBoolArr[(int)jt + Experiment.m_jointOffset]);
                }
            }
        }



        /// <summary>
        /// Refresh body every frame
        /// </summary>
        /// <param name="body">body that needs to be refreshed</param>
        private void RefreshBody(GameObject body)
        {
            m_reset = false;
            if (!m_reset && m_renderFrame < m_maxFrame - 3) //-3 because -1 just cause & -2 for current and next positions
            {
                Dictionary<Kinect.JointType, float[]> actionPositionData;
                Dictionary<Kinect.JointType, float[]> nextActionPositionData;
                GetActionPositionData(out actionPositionData, out nextActionPositionData);

                Dictionary<Kinect.JointType, float[]> actionOrientationData;
                Dictionary<Kinect.JointType, float[]> nextActionOrientationData;
                GetActionOrientationData(out actionOrientationData, out nextActionOrientationData);
                int i = 0;
                for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt <= Kinect.JointType.ThumbRight; jt++)
                {

                    //Modified by Olesia Kochergina - faster approach
                    Transform jointTran = body.transform.GetChild(i); //.FindChild(jt.ToString());
                    i++;
                    if (!m_exp.m_occBoolArr[(int)jt + Experiment.m_jointOffset])
                    {
                        //  GameObject.Find("Opponent/" + jt.ToString()).layer = LayerMask.NameToLayer("Occluded");
                        //Debug.Log("refreshbody23");
                        //continue;
                    }//else
                    {
                        if ((m_exp.m_occFrameMin[(int)jt + Experiment.m_jointOffset] >= m_renderFrame && m_exp.m_occFrameMax[(int)jt + Experiment.m_jointOffset] >= m_renderFrame)
                            || (m_exp.m_occFrameMin[(int)jt + Experiment.m_jointOffset] <= m_renderFrame && m_exp.m_occFrameMax[(int)jt + Experiment.m_jointOffset] <= m_renderFrame))
                        {
                            GameObject.Find("Opponent/" + jt.ToString()).layer = LayerMask.NameToLayer("Default");
                        }
                        else
                        {
                            GameObject.Find("Opponent/" + jt.ToString()).layer = LayerMask.NameToLayer("Occluded");
                        }
                    }
                    //Lerp Position
                    float[] nextActionPosition;
                    nextActionPositionData.TryGetValue(jt, out nextActionPosition);
                    SmoothPosition(jointTran, nextActionPosition, jt);

                    Kinect.JointType partner;
                    m_boneDic.TryGetValue(jt, out partner); //to be used later
                    //Lerp Rotation
                    float[] nextActionOrientation;
                    nextActionOrientationData.TryGetValue(jt, out nextActionOrientation);
                    //Debug.Log(jt.ToString());
                    if (SmoothRotation(jointTran, nextActionOrientation, jt) && jt == Kinect.JointType.ThumbRight)
                    {
                        if (m_renderFrame < m_maxFrame - 2)
                        {
                            IncRenderFrame();

                        }
                    }

                    //Draw Striker on hand joint
                    if (jt == Kinect.JointType.HandRight && m_HandRight)
                    {
                        RefreshStrikerOnHand(jointTran, FloatToQuat(nextActionOrientation), jt, m_exp.m_occBoolArr[0]);
                    }
                    else if (jt == Kinect.JointType.HandLeft && !m_HandRight)
                    {
                        RefreshStrikerOnHand(jointTran, FloatToQuat(nextActionOrientation), jt, m_exp.m_occBoolArr[0]);
                    }

                    RefreshBodyLines(body, actionPositionData, jointTran, jt);

                }
            }
            else
            {
                GameObject.Find("PlayButton").GetComponent<SportsKinematics.UI.Pause>().TaskOnClick(false);
                //m_reachedEnd = true;
                // Debug.Log("reached end: " + m_reset + "  " + m_renderFrame + "  " + m_maxFrame);
            }
        }

        /// <summary>
        /// refresh bones attached to joints
        /// </summary>
        /// <param name="body">body being refreshed</param>
        /// <param name="actionPositionData">action position for current frame</param>
        /// <param name="jointTran">transform of joint</param>
        /// <param name="jt">joint being drawn</param>
        public void RefreshBodyLines(GameObject body, Dictionary<Kinect.JointType, float[]> actionPositionData, Transform jointTran, Kinect.JointType jt)
        {
            if (jt != Kinect.JointType.Head)
            {
                float[] jointEnd = null;
                Kinect.JointType target;
                m_boneDic.TryGetValue(jt, out target);

                actionPositionData.TryGetValue(target, out jointEnd);

                Transform targetJointTran = body.transform.Find(target.ToString());

                if (m_drawLines && body.transform.Find(jt.ToString()).GetComponent<LineRenderer>())
                {
                    RefreshLineRender(body, jointTran.position, targetJointTran.position, jt);
                }
                else if (m_drawLines && GameObject.Find(jt.ToString()).GetComponent<LineRenderer>() == null)
                {
                    CreateLineRenderer(jt, jointTran.transform.position, FloatToVec(jointEnd));
                }
                else
                {
                    DisableLineRender(body, jt);
                }
            }
            else //if the head
            {
                //if (m_occBoolArr[(int)jt + Experiment.m_jointOffset])
                //{
                //    body.transform.FindChild(jt.ToString()).GetComponent<MeshRenderer>().material = m_activeJoint;
                //}
                //else
                //{
                //    body.transform.FindChild(jt.ToString()).GetComponent<MeshRenderer>().material = m_inactiveJoint;
                //}
            }
        }

        /// <summary>
        /// refresh the lines being drawn
        /// </summary>
        /// <param name="obj">GameObject for body in scene</param>
        /// <param name="jointStart">joint to start at as Vec3</param>
        /// <param name="jointEnd">joint to end at as Vec3</param>
        /// <param name="jt">joint being refreshed as JointType</param>
        private void RefreshLineRender(GameObject obj, Vector3 jointStart, Vector3 jointEnd, Kinect.JointType jt)
        {
            obj.transform.Find(jt.ToString()).GetComponent<LineRenderer>().enabled = true;
            Vector3[] arr = { jointStart, jointEnd };
            obj.transform.Find(jt.ToString()).GetComponent<LineRenderer>().SetPositions(arr);
        }

        /// <summary>
        /// turn off all lines
        /// </summary>
        /// <param name="obj">GameObject for body in scene</param>
        /// <param name="jt">joint to be rendered</param>
        private void DisableLineRender(GameObject obj, Kinect.JointType jt)
        {
            if (!m_drawLines && GameObject.Find("Opponent/" + jt.ToString()).GetComponent<LineRenderer>() != null)
            {
                obj.transform.Find(jt.ToString()).GetComponent<LineRenderer>().enabled = false;
            }
        }

        /// <summary>
        /// Create a line renderer for joints, if none exist
        /// </summary>
        /// <param name="jt">joint to attached line renderer to</param>
        /// <param name="jointStart">starting position of line</param>
        /// <param name="jointEnd">ending position of line</param>
        private void CreateLineRenderer(Kinect.JointType jt, Vector3 jointStart, Vector3 jointEnd)
        {
            LineRenderer lr = GameObject.Find("Opponent/" + jt.ToString()).AddComponent<LineRenderer>();
            lr.positionCount = 2;
            if (m_exp.m_occBoolArr[(int)jt + Experiment.m_jointOffset])
                lr.material = Occlusion.m_activeJoint;
            else
                lr.material = Occlusion.m_inactiveJoint;
            lr.startWidth = 0.05f;
            lr.endWidth = 0.05f;

            Vector3[] arr = { jointStart, jointEnd };
            lr.SetPositions(arr);
        }

        /// <summary>
        /// draw striker to hand of opponent
        /// </summary>
        /// <param name="jointTran">joint to have striker attached</param>
        /// <param name="jt">joint to be occluded</param>
        /// <param name="occluded">determine whether or not the striker should also be occluded.</param>
        private void CreateStrikerOnHand(Transform jointTran, Kinect.JointType jt, bool occluded)
        {
            m_strikerScript.CreateStriker(jointTran, occluded);
        }

        /// <summary>
        /// Refresh striker being drawn
        /// </summary>
        /// <param name="jointTran">transform of hand</param>
        /// <param name="nextOrientation">orientation to be applied</param>
        /// <param name="jt">joint to be refreshed</param>
        /// <param name="occluded">determine whter or not striker is occluded.</param>
        private void RefreshStrikerOnHand(Transform jointTran, Quaternion nextOrientation, Kinect.JointType jt, bool occluded)
        {
            m_strikerScript.RefreshStriker(jointTran, nextOrientation, occluded);
        }

        /// <summary>
        /// smooth the position of drawn joint
        /// </summary>
        /// <param name="jointTran">transform of joint to be drawn</param>
        /// <param name="nextActionPosition">next position of joint</param>
        /// <param name="jt">joint being refreshed</param>
        /// <returns>true if reached destination</returns>
        private bool SmoothPosition(Transform jointTran, float[] nextActionPosition, Kinect.JointType jt)
        {
            Vector3 nextPoint = FloatToVec(nextActionPosition);

            if (!isEqual(jointTran.localPosition, nextPoint))
            {
                jointTran.localPosition = Vector3.Lerp(jointTran.localPosition, nextPoint, m_LerpMinimum);
                return false;
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// smooth the orientation of drawn joint
        /// </summary>
        /// <param name="jointTran">transform of joint to be drawn</param>
        /// <param name="nextActionOrientation">next orientation of joint</param>
        /// <param name="jt">joint being refreshed</param>
        /// <returns>true if reached destination</returns>
        private bool SmoothRotation(Transform jointTran, float[] nextActionOrientation, Kinect.JointType jt)
        {
            Quaternion nextOrient = FloatToQuat(nextActionOrientation);
            if (!isEqual(jointTran.rotation, nextOrient))
            {
                jointTran.rotation = Quaternion.Lerp(jointTran.rotation, nextOrient, m_LerpMinimum);
                return false;
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// Toggles drawing of lines on joints
        /// </summary>
        public void ToggleLines()
        {
            m_drawLines = !m_drawLines;

            for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt < Kinect.JointType.ThumbRight; jt++)
            {
                RefreshBodyLines(m_trackedBody, m_action.CurrentActionPositionData[m_renderFrame], GameObject.Find("Opponent/" + jt.ToString()).transform, jt);
            }
            for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt < Kinect.JointType.ThumbRight; jt++)
            {
                RefreshBodyLines(m_trackedBody, m_action.CurrentActionPositionData[m_renderFrame], GameObject.Find("Opponent/" + jt.ToString()).transform, jt);
            }
        }

        /// <summary>
        /// convert float[] to vec
        /// </summary>
        /// <param name="vec">float[] to be converted</param>
        /// <returns>vector created from float[]</returns>
        private Vector3 FloatToVec(float[] vec)
        {
            return new Vector3(vec[0], vec[1], vec[2]);
        }

        /// <summary>
        /// covert float[] to quaternion
        /// </summary>
        /// <param name="quat">value to be converted</param>
        /// <returns>Quaternion created from conversion</returns>
        private Quaternion FloatToQuat(float[] quat)
        {
            return new Quaternion(quat[0], quat[1], quat[2], 1f);
        }

        /// <summary>
        /// determine if two Quaternions are equal
        /// </summary>
        /// <param name="lhs">left comparison</param>
        /// <param name="rhs">right comparison</param>
        /// <returns>true if matching</returns>
        private bool isEqual(Quaternion lhs, Quaternion rhs)
        {
            return (lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z && lhs.w == rhs.w);
        }

        /// <summary>
        /// Determine if two vec3s match
        /// </summary>
        /// <param name="lhs">left comparison</param>
        /// <param name="rhs">right comparison</param>
        /// <returns>true if matching</returns>
        private bool isEqual(Vector3 lhs, Vector3 rhs)
        {
            return (lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z);
        }

        /// <summary>
        /// Property; provides accessor for m_timer. READ-ONLY
        /// </summary>
        public float TimeElapsed
        {
            get { return m_timer; }
        }

        //Uses rkd.sampleRate, changing this value may reduce the
        //usefullness of older data
        //private float GetTimePerFrame()
        //{
        //    return (1.0f / float.Parse(m_rkd.m_sampleRate.ToString()));
        //}

        //public int GetFrameFromTime(float time)
        //{
        //    float timePerFrame = GetTimePerFrame();
        //    int frame = Convert.ToInt32((time*2.98f) / timePerFrame); //magic 2.98 for sampleRate shitness

        //    return frame;
        //}

        //Returns time in seconds
        //public float BallTimeToTarget(int targetFrame)
        //{
        //    float estTime = targetFrame * GetTimePerFrame();// sampleRate;
        //    //1000 is the scale between seconds and miliseconds
        //    return estTime / 1000.0f;
        //}

        /// <summary>
        /// Determines target for the ball
        /// </summary>
        /// <param name="body">body to target</param>
        public void DetermineBallTarget(GameObject body)
        {
            int targetFrame = m_conf.CollisionFrame;
            Dictionary<Kinect.JointType, float[]> targetBodyPosition = null;
            Dictionary<Kinect.JointType, float[]> targetBodyOrientation = null;


            //Refrence the Kinect joint dictionary
            if (targetFrame > 0 && targetFrame < m_action.CurrentActionPositionData.Count)
            {
                targetBodyPosition = m_action.CurrentActionPositionData[targetFrame];
                targetBodyOrientation = m_action.CurrentActionOrientationData[targetFrame];
            }
            else
            {
                Debug.Log("Target frame out of bounds!");
                return;
            }

            Kinect.JointType jt;
            float[] targetPosition;
            float[] targetOrientation;

            Transform hand;
            //Find the target joint based on which hand is used
            if (m_HandRight)
            {
                jt = Kinect.JointType.HandRight;
                targetBodyPosition.TryGetValue(jt, out targetPosition);
                targetBodyOrientation.TryGetValue(jt, out targetOrientation);
                hand = body.transform.Find("HandRight");
            }
            else
            {
                jt = Kinect.JointType.HandLeft;
                targetBodyPosition.TryGetValue(jt, out targetPosition);
                targetBodyOrientation.TryGetValue(jt, out targetOrientation);
                hand = body.transform.Find("HandLeft");
            }

            float[] tempTargetPositon = new float[3];
            tempTargetPositon[0] = targetPosition[0];
            tempTargetPositon[1] = targetPosition[1];
            tempTargetPositon[2] = -targetPosition[2];


            Vector3 targetVec = Vector3.one;
            targetVec.Scale(hand.lossyScale);
            targetVec = m_trackedBody.transform.rotation * FloatToQuat(targetOrientation) * targetVec;
            targetVec = m_trackedBody.transform.position - targetVec + FloatToVec(tempTargetPositon) + (FloatToQuat(targetOrientation) * new Vector3(0.152f, 2.4f, 0));

            //PREPARE TO FIRE
            m_ball.GetComponent<BallScript>().PrepareToFire(targetVec);
        }

        /// <summary>
        /// determine if frame should be incremented
        /// Modified: Olesia Kochergina (the elapsed time should be based on the fps and the speed of the simulation and not on the actual time)
        /// </summary>
        public void IncRenderFrame()
        {
            //if ((m_MAX_SPEED - m_speed) <= m_speedCounter)
            //{
            //    //Time inc
            //    float deltaTime = Time.time - m_lastTime;
            //    deltaTime /= m_speedCounter + 1;
            //    m_lastTime = Time.time;
            //    m_timer += deltaTime;

            //    if (m_hitOccured)
            //        m_occTimer += deltaTime;

            //    m_renderFrame++;
            //    m_speedCounter = 0;
            //}
            //else
            //    m_speedCounter++;
            m_timer = m_renderFrame / m_exp.m_speed;
        }

        /// <summary>
        /// reset scene
        /// </summary>
        public void ResetRenderFrame()
        {
            m_reset = true;
            m_renderFrame = m_exp.FrameStart;
            RefreshBody(m_trackedBody);
            if (m_conf != null)
                InitConfig(m_conf);
            m_occTimer = 0.0f;
            m_timer = 0.0f;
            m_reachedEnd = false;
            m_reset = false;
            m_lastTime = Time.time;

            m_maxFrame = m_exp.FrameEnd;
            if (m_ball && m_renderFrame != 0)
            {
                //Determine ball target
                //  DetermineBallTarget(m_trackedBody);
            }


        }

        /// <summary>
        /// saves data in an action file
        /// </summary>
        public void SaveData()
        {
            m_exp.m_ballSpeed = dball.m_ballSpeed;
            m_exp.m_ballDest = dball.m_destination;
            List<Dictionary<Kinect.JointType, float[]>> newActionPositionData = new List<Dictionary<Kinect.JointType, float[]>>();
            List<Dictionary<Kinect.JointType, float[]>> newActionOrientationData = new List<Dictionary<Kinect.JointType, float[]>>();

            //Changed by Olesia Kochergina: for (int i = 0; i < m_action.CurrentActionPositionData.Count; i++)
            for (int i = m_exp.FrameStart; i < m_exp.FrameEnd; i++)
            {
                // if (m_renderFrame <= i)
                {
                    newActionPositionData.Add(m_action.CurrentActionPositionData[i]);
                    newActionOrientationData.Add(m_action.CurrentActionOrientationData[i]);
                }
            }

            m_rkd.SaveEditedLogData("../Edited/" + m_action.Name, newActionPositionData, newActionOrientationData);
            m_exp.SaveSpatialOcclusion(m_action.Name);
        }



        /// <summary>
        /// saves data in a specified file
        /// </summary>
        public void SaveAsData(string filename)
        {
            m_action.Name = filename;
            SaveData();
        }

        /// <summary>
        /// accessor method for max speed. READ-ONLY
        /// </summary>
        public float MaxSpeed
        {
            get { return m_MAX_SPEED; }
        }
    }
}