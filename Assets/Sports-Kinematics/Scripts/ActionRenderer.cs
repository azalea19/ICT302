using System;
using System.Collections.Generic;
using UnityEngine;
using Kinect = Windows.Kinect;

namespace SportsKinematics
{
    public class ActionRenderer : MonoBehaviour
    {
        /// <summary>
        /// Action to be loaded
        /// </summary>
        private Action m_action;

        private float m_startTime;

        /// <summary>
        /// Script reference to draws striker object
        /// </summary>
        private StrikerRenderer m_strikerScript;

        /// <summary>
        /// Dictionary of JointType, JointType. Allows drawing of bones between joints.
        /// </summary>
        private Dictionary<Kinect.JointType, Kinect.JointType> m_boneDic;

        /// <summary>
        /// reference of player's body, dynamically generated by moCap system.
        /// </summary>
        private GameObject m_trackedBody = null;

        /// <summary>
        /// Frame currently being rendered
        /// </summary>
        private int m_renderFrame;

        /// <summary>
        /// scale used by kinect to resize cubes as joints
        /// </summary>
        private float[] m_kinectScale = { 0.3f, 0.3f, 0.3f };

        /// <summary>
        /// Applicable amount to Lerp
        /// </summary>
        private float m_LerpMinimum;

        /// <summary>
        /// Capture facade  script for data capture and member variable accessing
        /// </summary>
        private CaptureFacade m_captureFacade;

        /// <summary>
        /// Test for scene reset
        /// </summary>
        private bool m_reset;

        /// <summary>
        /// check if finished rendering all data
        /// </summary>
        private bool m_reachedEnd;

        /// <summary>
        /// used to change speed of render playback
        /// </summary>
        private int m_speedCounter;

        /// <summary>
        /// last time a function was called. Used to determine delta times.
        /// </summary>
        private float m_lastTime;

        /// <summary>
        /// time that simulation has been running, as scaled by speed. Displayed during editing.
        /// </summary>
        private float m_timer;

        /// <summary>
        /// time that simulation has been running, used for temporal occlusion.
        /// </summary>
        private float m_occTimer;

        /// <summary>
        /// time to release ball. Dynamically calculated.
        /// </summary>
        private float m_ballReleaseTime;

        /// <summary>
        /// frame to hit a paddle.
        /// </summary>
        private float m_ballTargetFrame;

        /// <summary>
        /// configuration for the action being replayed. Allows for scene resetting to affect configuration.
        /// </summary>
        private Configuration m_conf;

        /// <summary>
        /// occlusion array for spatial occlusion. True = shown.
        /// </summary>
        public bool[] m_occBoolArr;

        /// <summary>
        /// determine if hit has occured. on "no hit" temporal occlusion, sets to true on first frame. 
        /// </summary>
        public bool m_hitOccured;

        /// <summary>
        /// GameObject reference for capture facade
        /// </summary>
        public GameObject captureFacade;
        
        /// <summary>
        /// GameObject reference for record kinect data
        /// </summary>
        public GameObject recordKinectData;

        /// <summary>
        /// Script reference for record kinect data
        /// </summary>
        RecordKinectData m_rkd;

        /// <summary>
        /// material for colouring bones
        /// </summary>
        public Material m_boneMaterial;

        /// <summary>
        /// Game Object reference to striker manager for opponent. allows rendering of striker.
        /// </summary>
        public GameObject m_strikerManager;

        /// <summary>
        /// Ball prefab
        /// </summary>
        public GameObject m_ball;

        /// <summary>
        /// table prefab
        /// </summary>
        public GameObject m_table;

        /// <summary>
        /// Maximum allowable speed
        /// </summary>
        public const float m_MAX_SPEED = 100f;

        /// <summary>
        /// determine if opponent is playing right handed
        /// </summary>
        public bool m_HandRight;

        /// <summary>
        /// speed being rendered at
        /// </summary>
        public float m_speed;

        /// <summary>
        /// determine whether or not to draw lines on the opponent
        /// </summary>
        public bool m_drawLines;

        /// <summary>
        /// Max time before occlusion
        /// </summary>
        public float m_maxTime;

        /// <summary>
        /// determine whether or not to play back simulation
        /// </summary>
        public bool m_play;

        /// <summary>
        /// release time for ball
        /// </summary>
        private float m_releaseTime;

        /// <summary>
        /// Initiate the objects in scene
        /// </summary>
        void InitObjects()
        {
            m_captureFacade = captureFacade.GetComponent<CaptureFacade>();
            m_boneDic = m_captureFacade.BodyView.GetJointDic;
            m_strikerScript = m_strikerManager.GetComponent<StrikerRenderer>();
        }

        /// <summary>
        /// Initiate all non object data in scene
        /// </summary>
        void InitValues()
        {
            m_renderFrame = 0;
            m_drawLines = true;
            m_occBoolArr = new bool[25];
            m_occTimer = 0.0f;
            m_LerpMinimum = 1f;
            m_speedCounter = 0;
            m_maxTime = 0.001f;

            if (m_action == null)
                m_action = new Action();

            m_play = false;
            m_hitOccured = false;
            m_HandRight = true;
            m_reset = false;
        }

        /// <summary>
        /// GameObject start
        /// </summary>
        void Start()
        {
            if (recordKinectData && !m_rkd)
                m_rkd = recordKinectData.GetComponent<RecordKinectData>();

            InitObjects();
            InitValues();
        }

        /// <summary>
        /// accessor for render frame. READ-ONLY
        /// </summary>
        public int RenderFrame
        {
            get { return m_renderFrame; }
        }

        /// <summary>
        /// Occludes all joints drawn to screen. Used to apply temporal occlusion
        /// </summary>
        void OccludeAllJoints()
        {
            for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt <= Kinect.JointType.ThumbRight; jt++)
            {
                m_occBoolArr[(int)jt] = false;

                if (jt == Kinect.JointType.ThumbRight)
                {
                    m_ball.layer = LayerMask.NameToLayer("Occluded");
                }
            }
        }

        /// <summary>
        /// locally store a configuration, and apply it to the scene
        /// </summary>
        /// <param name="conf">configuration to be initialised</param>
        public void InitConfig(Configuration conf)
        {
            m_occBoolArr = conf.OcclusionArray;

            if (!conf.TemporalOnHitIsActive)
            {
                m_maxTime = 0.0f;
                m_hitOccured = true;
            }

            if (conf.OcclusionTime != 0.0f)
                m_maxTime = conf.OcclusionTime;

            if (conf.CollisionFrame != 0.0f)
            {
                m_ballTargetFrame = conf.CollisionFrame;//*1000.0f;
                m_releaseTime = (float.Parse(m_ballTargetFrame.ToString()) / 50f) - 0.02f; //fixed update rate
            }

            m_strikerScript.m_StrikerSelection = conf.Sport;
            m_HandRight = conf.OpponentRightHanded;

            if (conf.Sport != 0)
            {
                //m_strikerScript.m_start = conf.StartingRotation;
                //m_strikerScript.m_final = conf.EndingRotation;
            }

            GameObject playerStriker = GameObject.Find("SportsKinematics/Retriever");

            if (playerStriker)
            {
                playerStriker.GetComponent<PlayerTracker>().LoadConf(conf);
            }

            m_conf = conf;
        }

        /// <summary>
        /// Update loop. runs on physics engine and is guaranteed to occur at 50 fps
        /// </summary>
        void FixedUpdate()
        {
            if (m_play && m_speed != 0.0f && !m_reachedEnd)
            {
                if (m_trackedBody)
                {
                    try
                    {
                        RefreshBody(m_trackedBody);
                    }
                    catch
                    {
                        Debug.Log("Body not found!");
                    }
                }

                if (m_ball)
                {
                    if (m_timer >= m_releaseTime - m_ball.GetComponent<BallScript>().TimeOfCollide)
                    {
                        m_ball.GetComponent<BallScript>().m_triggerBall = true;
                    }
                }

            }
            else
            {
                m_lastTime = Time.time;
            }

            if ((m_occTimer >= m_maxTime && m_maxTime > 0.0f) || (m_hitOccured && m_maxTime == 0.001f))
            {
                OccludeAllJoints();
            }
        }

        /// <summary>
        /// Initiate the render body for opponent actions
        /// </summary>
        /// <param name="action">action data to display</param>
        public void InitiateRenderBody(Action action)
        {
            if (!m_captureFacade)
            {
                InitObjects();
                InitValues();
            }

            m_action = action;

            if (m_trackedBody == null)
            {
                try
                {
                    m_trackedBody = RenderBody();
                    if (m_ball)
                    {
                        //Determine ball target
                        DetermineBallTarget(m_trackedBody);
                    }
                }
                catch
                {
                }
            }
        }

        /// <summary>
        /// Access Action position data for current and next frame
        /// </summary>
        /// <param name="actionPosition">current frame data as Dictionary of JointType to float[3]</param>
        /// <param name="nextActionPosition">next frame data as Dictionary of JointType to float[3]</param>
        public void GetActionPositionData(out Dictionary<Kinect.JointType, float[]> actionPosition, out Dictionary<Kinect.JointType, float[]> nextActionPosition)
        {
            actionPosition = m_action.CurrentActionPositionData[m_renderFrame];
            nextActionPosition = m_action.CurrentActionPositionData[m_renderFrame + 1];
        }

        /// <summary>
        /// Access Action orientation data for current and next frame
        /// </summary>
        /// <param name="actionOrientation">current frame data as Dictionary of JointType to float[3]</param>
        /// <param name="nextActionOrientation">next frame data as Dictionary of JointType to float[3]</param>
        public void GetActionOrientationData(out Dictionary<Kinect.JointType, float[]> actionOrientation, out Dictionary<Kinect.JointType, float[]> nextActionOrientation)
        {
            actionOrientation = m_action.CurrentActionOrientationData[m_renderFrame];
            nextActionOrientation = m_action.CurrentActionOrientationData[m_renderFrame + 1];
        }

        /// <summary>
        /// Render the opponent body
        /// </summary>
        /// <returns>returns the body that was drawn</returns>
        //FR1 - Virtual opponent modelling from captured data.
        private GameObject RenderBody()
        {
            GameObject body = new GameObject("Opponent");
            body.transform.position = new Vector3(0.0f, 11.97f, 20.08f);
            body.transform.rotation = new Quaternion(0f, 180f, 0f, 1f);
            body.transform.localScale = new Vector3(-1f, 1f, 1f);
            RenderJoints(body);
            RefreshBody(body);
            RefreshBody(body);  //fixes a transform issue
            ResetRenderFrame();

            return body;
        }

        /// <summary>
        /// Render joints to screen and draw striker
        /// </summary>
        /// <param name="body">body that has been rendered</param>
        public void RenderJoints(GameObject body)
        {
            Dictionary<Kinect.JointType, float[]> actionPositionData;
            Dictionary<Kinect.JointType, float[]> nextActionPositionData;
            GetActionPositionData(out actionPositionData, out nextActionPositionData);

            Dictionary<Kinect.JointType, float[]> actionOrientationData;
            Dictionary<Kinect.JointType, float[]> nextActionOrientationData;
            GetActionOrientationData(out actionOrientationData, out nextActionOrientationData);

            for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt <= Kinect.JointType.ThumbRight; jt++)
            {
                GameObject jointObj = GameObject.CreatePrimitive(PrimitiveType.Cube);

                jointObj.GetComponent<MeshRenderer>().material = m_boneMaterial;

                jointObj.transform.localScale = FloatToVec(m_kinectScale);
                jointObj.name = jt.ToString();

                Kinect.JointType target;
                m_boneDic.TryGetValue(jt, out target);

                float[] jointStart;
                actionPositionData.TryGetValue(jt, out jointStart);

                float[] jointEnd = null;
                actionPositionData.TryGetValue(target, out jointEnd);

                jointObj.transform.parent = body.transform;
                jointObj.transform.localPosition = FloatToVec(jointStart);

                if (!m_occBoolArr[(int)jt])
                {
                    GameObject.Find("Opponent/" + jt.ToString()).layer = LayerMask.NameToLayer("Occluded");
                }

                //draw striker
                if (jt == Kinect.JointType.HandRight && m_HandRight) {
                    CreateStrikerOnHand(jointObj.transform, jt, m_occBoolArr[(int)jt]);
                }
                else if (jt == Kinect.JointType.HandLeft && !m_HandRight)
                {
                    CreateStrikerOnHand(jointObj.transform, jt, m_occBoolArr[(int)jt]);
                }
            }
        }

        /// <summary>
        /// Refresh body every frame
        /// </summary>
        /// <param name="body">body that needs to be refreshed</param>
        private void RefreshBody(GameObject body)
        {
            if (!m_reset && m_renderFrame < m_action.Count - 3) //-3 because -1 just cause & -2 for current and next positions
            {
                Dictionary<Kinect.JointType, float[]> actionPositionData;
                Dictionary<Kinect.JointType, float[]> nextActionPositionData;
                GetActionPositionData(out actionPositionData, out nextActionPositionData);

                Dictionary<Kinect.JointType, float[]> actionOrientationData;
                Dictionary<Kinect.JointType, float[]> nextActionOrientationData;
                GetActionOrientationData(out actionOrientationData, out nextActionOrientationData);

                for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt <= Kinect.JointType.ThumbRight; jt++)
                {
                    Transform jointTran = body.transform.Find(jt.ToString());

                    if (!m_occBoolArr[(int)jt])
                    {
                        GameObject.Find("Opponent/" + jt.ToString()).layer = LayerMask.NameToLayer("Occluded");
                    }

                    //Lerp Position
                    float[] nextActionPosition;
                    nextActionPositionData.TryGetValue(jt, out nextActionPosition);
                    SmoothPosition(jointTran, nextActionPosition, jt);

                    Kinect.JointType partner;
                    m_boneDic.TryGetValue(jt, out partner); //to be used later

                    //Lerp Rotation
                    float[] nextActionOrientation;
                    nextActionOrientationData.TryGetValue(jt, out nextActionOrientation);

                    if (SmoothRotation(jointTran, nextActionOrientation, jt) && jt == Kinect.JointType.ThumbRight)
                    {
                        if (m_renderFrame < m_action.Count - 2)
                        {
                            IncRenderFrame();
                        }
                    }

                    //Draw Striker on hand joint
                    if (jt == Kinect.JointType.HandRight && m_HandRight)
                    {
                        RefreshStrikerOnHand(jointTran, FloatToQuat(nextActionOrientation), jt, m_occBoolArr[(int)jt]);
                    }
                    else if(jt == Kinect.JointType.HandLeft && !m_HandRight)
                    {
                        RefreshStrikerOnHand(jointTran, FloatToQuat(nextActionOrientation), jt, m_occBoolArr[(int)jt]);
                    }

                    RefreshBodyLines(body, actionPositionData, jointTran, jt);
                }
            }
            else
            {
                m_reachedEnd = true;
            }
        }

        /// <summary>
        /// refresh bones attached to joints
        /// </summary>
        /// <param name="body">body being refreshed</param>
        /// <param name="actionPositionData">action position for current frame</param>
        /// <param name="jointTran">transform of joint</param>
        /// <param name="jt">joint being drawn</param>
        public void RefreshBodyLines(GameObject body, Dictionary<Kinect.JointType, float[]> actionPositionData, Transform jointTran, Kinect.JointType jt)
        {
            if (jt != Kinect.JointType.Head)
            {
                float[] jointEnd = null;
                Kinect.JointType target;
                m_boneDic.TryGetValue(jt, out target);

                actionPositionData.TryGetValue(target, out jointEnd);

                Transform targetJointTran = body.transform.Find(target.ToString());

                if (m_drawLines && body.transform.Find(jt.ToString()).GetComponent<LineRenderer>())
                {
                    RefreshLineRender(body, jointTran.position, targetJointTran.position, jt);
                }
                else if (m_drawLines && GameObject.Find(jt.ToString()).GetComponent<LineRenderer>() == null)
                {
                    CreateLineRenderer(jt, jointTran.transform.position, FloatToVec(jointEnd));
                }
                else
                {
                    DisableLineRender(body, jt);
                }
            }
        }

        /// <summary>
        /// refresh the lines being drawn
        /// </summary>
        /// <param name="obj">GameObject for body in scene</param>
        /// <param name="jointStart">joint to start at as Vec3</param>
        /// <param name="jointEnd">joint to end at as Vec3</param>
        /// <param name="jt">joint being refreshed as JointType</param>
        private void RefreshLineRender(GameObject obj, Vector3 jointStart, Vector3 jointEnd, Kinect.JointType jt)
        {
            obj.transform.Find(jt.ToString()).GetComponent<LineRenderer>().enabled = true;
            Vector3[] arr = { jointStart, jointEnd };
            obj.transform.Find(jt.ToString()).GetComponent<LineRenderer>().SetPositions(arr);
        }

        /// <summary>
        /// turn off all lines
        /// </summary>
        /// <param name="obj">GameObject for body in scene</param>
        /// <param name="jt">joint to be rendered</param>
        private void DisableLineRender(GameObject obj, Kinect.JointType jt)
        {
            if (!m_drawLines && GameObject.Find("Opponent/" + jt.ToString()).GetComponent<LineRenderer>() != null)
            {
                obj.transform.Find(jt.ToString()).GetComponent<LineRenderer>().enabled = false;
            }
        }

        /// <summary>
        /// Create a line renderer for joints, if none exist
        /// </summary>
        /// <param name="jt">joint to attached line renderer to</param>
        /// <param name="jointStart">starting position of line</param>
        /// <param name="jointEnd">ending position of line</param>
        private void CreateLineRenderer(Kinect.JointType jt, Vector3 jointStart, Vector3 jointEnd)
        {
            LineRenderer lr = GameObject.Find("Opponent/" + jt.ToString()).AddComponent<LineRenderer>();
            lr.positionCount = 2;
            lr.material = m_boneMaterial;
            lr.startWidth = 0.05f;
            lr.endWidth = 0.05f;

            Vector3[] arr = { jointStart, jointEnd };
            lr.SetPositions(arr);
        }

        /// <summary>
        /// draw striker to hand of opponent
        /// </summary>
        /// <param name="jointTran">joint to have striker attached</param>
        /// <param name="jt">joint to be occluded</param>
        /// <param name="occluded">determine whether or not the striker should also be occluded.</param>
        private void CreateStrikerOnHand(Transform jointTran, Kinect.JointType jt, bool occluded)
        { 
            m_strikerScript.CreateStriker(jointTran, occluded);
        }

        /// <summary>
        /// Refresh striker being drawn
        /// </summary>
        /// <param name="jointTran">transform of hand</param>
        /// <param name="nextOrientation">orientation to be applied</param>
        /// <param name="jt">joint to be refreshed</param>
        /// <param name="occluded">determine whter or not striker is occluded.</param>
        private void RefreshStrikerOnHand(Transform jointTran, Quaternion nextOrientation, Kinect.JointType jt, bool occluded)
        {
            m_strikerScript.RefreshStriker(jointTran, nextOrientation, occluded);
        }

        /// <summary>
        /// smooth the position of drawn joint
        /// </summary>
        /// <param name="jointTran">transform of joint to be drawn</param>
        /// <param name="nextActionPosition">next position of joint</param>
        /// <param name="jt">joint being refreshed</param>
        /// <returns>true if reached destination</returns>
        private bool SmoothPosition(Transform jointTran, float[] nextActionPosition, Kinect.JointType jt)
        {
            Vector3 nextPoint = FloatToVec(nextActionPosition);

            if (!isEqual(jointTran.localPosition, nextPoint))
            {
                jointTran.localPosition = Vector3.Lerp(jointTran.localPosition, nextPoint, m_LerpMinimum);
                return false;
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// smooth the orientation of drawn joint
        /// </summary>
        /// <param name="jointTran">transform of joint to be drawn</param>
        /// <param name="nextActionOrientation">next orientation of joint</param>
        /// <param name="jt">joint being refreshed</param>
        /// <returns>true if reached destination</returns>
        private bool SmoothRotation(Transform jointTran, float[] nextActionOrientation, Kinect.JointType jt)
        {
            Quaternion nextOrient = FloatToQuat(nextActionOrientation);

            if (!isEqual(jointTran.rotation, nextOrient))
            {
                jointTran.rotation = Quaternion.Lerp(jointTran.rotation, nextOrient, m_LerpMinimum);
                return false;
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// Toggles drawing of lines on joints
        /// </summary>
        public void ToggleLines()
        {
            m_drawLines = !m_drawLines;

            for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt < Kinect.JointType.ThumbRight; jt++)
            {
                RefreshBodyLines(m_trackedBody, m_action.CurrentActionPositionData[m_renderFrame], GameObject.Find("Opponent/" + jt.ToString()).transform, jt);
            }
            for (Kinect.JointType jt = Kinect.JointType.SpineBase; jt < Kinect.JointType.ThumbRight; jt++)
            {
                RefreshBodyLines(m_trackedBody, m_action.CurrentActionPositionData[m_renderFrame], GameObject.Find("Opponent/" + jt.ToString()).transform, jt);
            }
        }

        /// <summary>
        /// convert float[] to vec
        /// </summary>
        /// <param name="vec">float[] to be converted</param>
        /// <returns>vector created from float[]</returns>
        private Vector3 FloatToVec(float[] vec)
        {
            return new Vector3(vec[0], vec[1], vec[2]);
        }

        /// <summary>
        /// covert float[] to quaternion
        /// </summary>
        /// <param name="quat">value to be converted</param>
        /// <returns>Quaternion created from conversion</returns>
        private Quaternion FloatToQuat(float[] quat)
        {
            return new Quaternion(quat[0], quat[1], quat[2], 1f);
        }

        /// <summary>
        /// determine if two Quaternions are equal
        /// </summary>
        /// <param name="lhs">left comparison</param>
        /// <param name="rhs">right comparison</param>
        /// <returns>true if matching</returns>
        private bool isEqual(Quaternion lhs, Quaternion rhs)
        {
            return (lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z && lhs.w == rhs.w);
        }

        /// <summary>
        /// Determine if two vec3s match
        /// </summary>
        /// <param name="lhs">left comparison</param>
        /// <param name="rhs">right comparison</param>
        /// <returns>true if matching</returns>
        private bool isEqual(Vector3 lhs, Vector3 rhs)
        {
            return (lhs.x == rhs.x && lhs.y == rhs.y && lhs.z == rhs.z);
        }

        /// <summary>
        /// Property; provides accessor for m_timer. READ-ONLY
        /// </summary>
        public float TimeElapsed
        {
            get { return m_timer; }
        }

        //Uses rkd.sampleRate, changing this value may reduce the
        //usefullness of older data
        //private float GetTimePerFrame()
        //{
        //    return (1.0f / float.Parse(m_rkd.m_sampleRate.ToString()));
        //}

        //public int GetFrameFromTime(float time)
        //{
        //    float timePerFrame = GetTimePerFrame();
        //    int frame = Convert.ToInt32((time*2.98f) / timePerFrame); //magic 2.98 for sampleRate shitness

        //    return frame;
        //}

        //Returns time in seconds
        //public float BallTimeToTarget(int targetFrame)
        //{
        //    float estTime = targetFrame * GetTimePerFrame();// sampleRate;
        //    //1000 is the scale between seconds and miliseconds
        //    return estTime / 1000.0f;
        //}

        /// <summary>
        /// Determines target for the ball
        /// </summary>
        /// <param name="body">body to target</param>
        public void DetermineBallTarget(GameObject body)
        {
            int targetFrame = m_conf.CollisionFrame;
            Dictionary<Kinect.JointType, float[]> targetBodyPosition = null;
            Dictionary<Kinect.JointType, float[]> targetBodyOrientation = null;


            //Refrence the Kinect joint dictionary
            if (targetFrame > 0 && targetFrame < m_action.CurrentActionPositionData.Count)
            {
                targetBodyPosition = m_action.CurrentActionPositionData[targetFrame];
                targetBodyOrientation = m_action.CurrentActionOrientationData[targetFrame];
            }
            else
            {
                Debug.Log("Target frame out of bounds!");
                return;
            }

            Kinect.JointType jt;
            float[] targetPosition;
            float[] targetOrientation;

            Transform hand;
            //Find the target joint based on which hand is used
            if (m_HandRight)
            {
                jt = Kinect.JointType.HandRight;
                targetBodyPosition.TryGetValue(jt, out targetPosition);
                targetBodyOrientation.TryGetValue(jt, out targetOrientation);
                hand = body.transform.Find("HandRight");
            }
            else
            {
                jt = Kinect.JointType.HandLeft;
                targetBodyPosition.TryGetValue(jt, out targetPosition);
                targetBodyOrientation.TryGetValue(jt, out targetOrientation);
                hand = body.transform.Find("HandLeft");
            }

            float[] tempTargetPositon = new float[3];
            tempTargetPositon[0] = targetPosition[0];
            tempTargetPositon[1] = targetPosition[1];
            tempTargetPositon[2] = -targetPosition[2];


            Vector3 targetVec = Vector3.one;
            targetVec.Scale(hand.lossyScale);
            targetVec = m_trackedBody.transform.rotation * FloatToQuat(targetOrientation) * targetVec;
            targetVec = m_trackedBody.transform.position - targetVec + FloatToVec(tempTargetPositon) + (FloatToQuat(targetOrientation) * new Vector3(0.152f, 2.4f, 0));

            //PREPARE TO FIRE
            m_ball.GetComponent<BallScript>().PrepareToFire(targetVec);
        }

        /// <summary>
        /// determine if frame should be incremented
        /// </summary>
        public void IncRenderFrame()
        {
            if ((m_MAX_SPEED - m_speed) <= m_speedCounter)
            {
                //Time inc
                float deltaTime = Time.time - m_lastTime;
                deltaTime /= m_speedCounter + 1;
                m_lastTime = Time.time;
                m_timer += deltaTime;

                if (m_hitOccured)
                    m_occTimer += deltaTime;

                m_renderFrame++;
                m_speedCounter = 0;
            }
            else
                m_speedCounter++;
        }

        /// <summary>
        /// reset scene
        /// </summary>
        public void ResetRenderFrame()
        {
            m_reset = true;
            m_renderFrame = 0;
            RefreshBody(m_trackedBody);
            if(m_conf != null)
                InitConfig(m_conf);
            m_occTimer = 0.0f;
            m_timer = 0.0f;
            m_reachedEnd = false;
            m_reset = false;
            m_lastTime = Time.time;

            if (m_ball && m_renderFrame != 0)
            {
                //Determine ball target
                DetermineBallTarget(m_trackedBody);
            }
        }

        /// <summary>
        /// saves data being trimmed
        /// </summary>
        public void SaveTrimmedData()
        {
            List<Dictionary<Kinect.JointType, float[]>> newActionPositionData = new List<Dictionary<Kinect.JointType, float[]>>();
            List<Dictionary<Kinect.JointType, float[]>> newActionOrientationData = new List<Dictionary<Kinect.JointType, float[]>>();
            
            for (int i = 0; i < m_action.CurrentActionPositionData.Count; i++)
            {
                if (m_renderFrame <= i)
                {
                    newActionPositionData.Add(m_action.CurrentActionPositionData[i]);
                    newActionOrientationData.Add(m_action.CurrentActionOrientationData[i]);
                }
            }

            m_rkd.SaveEditedLogData("../Edited/" + m_action.Name, newActionPositionData, newActionOrientationData);
        }

        /// <summary>
        /// saves data from slicing
        /// </summary>
        public void SaveSlicedData()
        {
            List<Dictionary<Kinect.JointType, float[]>> newActionPositionData = new List<Dictionary<Kinect.JointType, float[]>>();
            List<Dictionary<Kinect.JointType, float[]>> newActionOrientationData = new List<Dictionary<Kinect.JointType, float[]>>();

            for (int i = 0; i < m_action.CurrentActionPositionData.Count; i++)
            {
                newActionPositionData.Add(m_action.CurrentActionPositionData[i]);
                newActionOrientationData.Add(m_action.CurrentActionOrientationData[i]);

                if (m_renderFrame == i)
                {
                    m_rkd.SaveEditedLogData("../Edited/" + m_action.Name +"Slice-1", newActionPositionData, newActionOrientationData);
                    newActionPositionData.Clear();
                    newActionOrientationData.Clear();
                }
                else if (i == m_action.CurrentActionPositionData.Count - 1)
                {
                    m_rkd.SaveEditedLogData("../Edited/" + m_action.Name + "Slice-2", newActionPositionData, newActionOrientationData);
                    newActionPositionData.Clear();
                    newActionOrientationData.Clear();
                }
            }
        }

        /// <summary>
        /// accessor method for max speed. READ-ONLY
        /// </summary>
        public float MaxSpeed
        {
            get { return m_MAX_SPEED; }
        }
    }
}